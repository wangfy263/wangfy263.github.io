<!DOCTYPE html>
<html lang="zn">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Wang">
    <meta name="description" content="John Doe&#39;s personal website">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="手动实现一个promise/A&#43;"/>
<meta name="twitter:description" content="开始 用了这么久Promise，今天突然想研究下Promise是怎么实现的，并且自己实现一个。
准备工作 既然要手动实现一个Promise,那么先看看我们经常使用的Promise是什么样子的；
使用样例 let promise = new Promise(function(resolve,reject){ resolve(&#34;success&#34;); }) promise.then(function(value){ }, function(reason){ })  从样例上看，Promise是一个构造函数，并且有一个参数excutor，这个参数是一个函数，也有两个函数作为参数，resolve和reject，resolve和reject是Promise内部的两个函数 then方法是原型链上的方法，接收两个入参（函数），这两个函数分别对应Promise的变更为resolve状态和reject状态后要执行的操作；
除了样例，我们还应该了解下Promise/A&#43;规范。
Promise/A&#43;规范 全文翻译：
Promise状态 一个promise必须处于一下三种状态：pending、fulfilled或者rejected。 * pending状态：promise可以转成fulfilled和rejected状态 * fulfilled状态：promise的状态不可变更，并且必须有一个值，且这个值不能被改变； * rejected状态： promise的状态不可变更，并且必须有一个原因，且这个原因不可改变；
then方法 promise必须包含一个then方法来访问它当前或者最终的值或者原因。 Promise的then方法接收两个参数：promise.then(onFulfilled, onRejected) * onFulfilled和onRejected必须是一个函数； * onFulfilled在promise到fulfilled状态后触发，promise的值是它的第一个参数。（onFulfilled只能触发一次，且在promise状态变成fulfilled之前不能触发） * onRejected在promise到rejected状态后触发，promise的原因是它的第一个参数。（onRejected只能触发一次，且在promise状态变成rejected之前不能触发） * then方法可能在相同的promise中被调用多次。onFulfilled和onRejected必须按照原有顺序进行调用执行；
这里先列举基础的部分；
promise实现&mdash;part 1 从上面的信息我们可以模拟出Promise的基本结构
const PENDING = &#34;pending&#34;; const RESOLVED = &#34;fulfilled&#34;; const REJECTED = &#34;rejected&#34;; function Promise(excutor){ const that = this; that.status = PENDING; // 初始状态为pending  that."/>


    <base href="https://wangfy263.github.io/unfinished/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise-a/">
    <title>
  手动实现一个promise/A&#43; · Wang
</title>

    <link rel="canonical" href="https://wangfy263.github.io/unfinished/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AApromise-a/">

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Merriweather:300,700|Source+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://wangfy263.github.io/css/coder.min.ac37073bc2826cd28ef57364a9fe339de7ebcb26dafc22fd832cb35cf5b1d048.css" integrity="sha256-rDcHO8KCbNKO9XNkqf4znefryyba/CL9gyyzXPWx0Eg=" crossorigin="anonymous" media="screen" />
    

    

    

    

    <link rel="icon" type="image/png" href="https://wangfy263.github.io/images/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://wangfy263.github.io/images/favicon-16x16.png" sizes="16x16">

    

    <meta name="generator" content="Hugo 0.54.0" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://wangfy263.github.io/">
      Wang
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://wangfy263.github.io/about/">About</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://wangfy263.github.io/posts/">Blog</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://wangfy263.github.io/projects/">Projects</a>
          </li>
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://wangfy263.github.io/contact/">Contact me</a>
          </li>
        
      
      
        
        
        
          
        
          
            
              <li class="navigation-item menu-separator">
                <span>|</span>
              </li>
              
            
            <li class="navigation-item">
              <a href="https://wangfy263.github.io/zn/">中文</a>
            </li>
          
        
      
    </ul>
  </section>
</nav>


      <div class="content">
        
  <section class="container page">
  <article>
    <header>
      <h1>手动实现一个promise/A&#43;</h1>
    </header>

    

<h2 id="开始">开始</h2>

<p>用了这么久Promise，今天突然想研究下Promise是怎么实现的，并且自己实现一个。</p>

<h2 id="准备工作">准备工作</h2>

<p>既然要手动实现一个Promise,那么先看看我们经常使用的Promise是什么样子的；</p>

<h3 id="使用样例">使用样例</h3>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#fff;font-weight:bold">let</span> promise = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">Promise</span>(<span style="color:#fff;font-weight:bold">function</span>(resolve,reject){
    resolve(<span style="color:#0ff;font-weight:bold">&#34;success&#34;</span>); 
})
promise.then(<span style="color:#fff;font-weight:bold">function</span>(value){

}, <span style="color:#fff;font-weight:bold">function</span>(reason){

})
</code></pre></div>
<p>从样例上看，Promise是一个构造函数，并且有一个参数excutor，这个参数是一个函数，也有两个函数作为参数，resolve和reject，resolve和reject是Promise内部的两个函数
then方法是原型链上的方法，接收两个入参（函数），这两个函数分别对应Promise的变更为resolve状态和reject状态后要执行的操作；</p>

<p>除了样例，我们还应该了解下Promise/A+规范。</p>

<h2 id="promise-a-规范">Promise/A+规范</h2>

<p>全文翻译：</p>

<h3 id="promise状态">Promise状态</h3>

<p>一个promise必须处于一下三种状态：pending、fulfilled或者rejected。
* pending状态：promise可以转成fulfilled和rejected状态
* fulfilled状态：promise的状态不可变更，并且必须有一个值，且这个值不能被改变；
* rejected状态： promise的状态不可变更，并且必须有一个原因，且这个原因不可改变；</p>

<h3 id="then方法">then方法</h3>

<p>promise必须包含一个then方法来访问它当前或者最终的值或者原因。
Promise的then方法接收两个参数：promise.then(onFulfilled, onRejected)
* onFulfilled和onRejected必须是一个函数；
* onFulfilled在promise到fulfilled状态后触发，promise的值是它的第一个参数。（onFulfilled只能触发一次，且在promise状态变成fulfilled之前不能触发）
* onRejected在promise到rejected状态后触发，promise的原因是它的第一个参数。（onRejected只能触发一次，且在promise状态变成rejected之前不能触发）
* then方法可能在相同的promise中被调用多次。onFulfilled和onRejected必须按照原有顺序进行调用执行；</p>

<p>这里先列举基础的部分；</p>

<h2 id="promise实现-part-1">promise实现&mdash;part 1</h2>

<p>从上面的信息我们可以模拟出Promise的基本结构</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#fff;font-weight:bold">const</span> PENDING = <span style="color:#0ff;font-weight:bold">&#34;pending&#34;</span>;
<span style="color:#fff;font-weight:bold">const</span> RESOLVED = <span style="color:#0ff;font-weight:bold">&#34;fulfilled&#34;</span>;
<span style="color:#fff;font-weight:bold">const</span> REJECTED = <span style="color:#0ff;font-weight:bold">&#34;rejected&#34;</span>;
<span style="color:#fff;font-weight:bold">function</span> <span style="color:#fff;font-weight:bold">Promise</span>(excutor){
    <span style="color:#fff;font-weight:bold">const</span> that = <span style="color:#fff;font-weight:bold">this</span>;
    that.status = PENDING;    <span style="color:#007f7f">// 初始状态为pending
</span><span style="color:#007f7f"></span>    that.value = <span style="color:#fff;font-weight:bold">undefined</span>;
    that.reason = <span style="color:#fff;font-weight:bold">undefined</span>;
    that.onFullfilledList = [];  <span style="color:#007f7f">// 存放onFullfilled函数的列表，多次调用then，会有多个onFullfilled函数
</span><span style="color:#007f7f"></span>    that.onRejectedList = [];   <span style="color:#007f7f">// 作用同上
</span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">function</span> resolve(value){
        <span style="color:#fff;font-weight:bold">if</span>(that.status === PENDING) {
            that.status = RESOLVED;
            that.value = value;
            that.onFullfilledList.forEach(<span style="color:#fff;font-weight:bold">function</span>(fullfilled){
                fullfilled(value);
            })
        }
    }
    <span style="color:#fff;font-weight:bold">function</span> reject(reason){
        <span style="color:#fff;font-weight:bold">if</span> (<span style="color:#fff;font-weight:bold">this</span>.state === <span style="color:#0ff;font-weight:bold">&#39;pending&#39;</span>) {
            that.status = REJECTED;
            that.reason = reason;
            that.onRejectedList.forEach(<span style="color:#fff;font-weight:bold">function</span>(rejected){
                rejected(reason);
            })
        }
    }
    <span style="color:#fff;font-weight:bold">try</span>{
        excutor(resolve, reject)
    }<span style="color:#fff;font-weight:bold">catch</span>(err){
        reject(err)
    }
}
<span style="color:#fff;font-weight:bold">Promise</span>.prototype.then = <span style="color:#fff;font-weight:bold">function</span>(onFullfilled, onRejected) {
    <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">this</span>.status === RESOLVED &amp;&amp; <span style="color:#fff;font-weight:bold">Object</span>.prototype.toString.call(onFullfilled) === <span style="color:#0ff;font-weight:bold">&#34;[object Function]&#34;</span>){
        onFullfilled(<span style="color:#fff;font-weight:bold">this</span>.value);  <span style="color:#007f7f">// fulfilled状态则立即执行onFullfilled函数
</span><span style="color:#007f7f"></span>    }
    <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">this</span>.status === REJECTED &amp;&amp;<span style="color:#fff;font-weight:bold">Object</span>.prototype.toString.call(onRejected) === <span style="color:#0ff;font-weight:bold">&#34;[object Function]&#34;</span>){
        onRejected(<span style="color:#fff;font-weight:bold">this</span>.reason);  <span style="color:#007f7f">// rejected状态则立即执行onRejected函数
</span><span style="color:#007f7f"></span>    }
    <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">this</span>.status === PENDING){
        <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">Object</span>.prototype.toString.call(onFullfilled) === <span style="color:#0ff;font-weight:bold">&#34;[object Function]&#34;</span>){
            <span style="color:#fff;font-weight:bold">this</span>.onFullfilledList.push(onFullfilled);  <span style="color:#007f7f">// 注册onFullfilled
</span><span style="color:#007f7f"></span>        }
        <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">Object</span>.prototype.toString.call(onRejected) === <span style="color:#0ff;font-weight:bold">&#34;[object Function]&#34;</span>){
            <span style="color:#fff;font-weight:bold">this</span>.onRejectedList.push(onRejected);     <span style="color:#007f7f">// 注册onRejected
</span><span style="color:#007f7f"></span>        }
    }
}
</code></pre></div>
<p>这样基本满足了上面所列的规范中的重点，但规范并不只有这些；</p>

<h2 id="promise实现-part-2">promise实现&mdash;part 2</h2>

<p>规范中还对then方法有约束：
* then方法必须返回一个promise： promise2 = promise1.then(onFulfilled, onRejected);
* 如果onFulfilled或者onRejected方法返回一个值x，那么执行promise的解析过程 <a href="https://wangfy263.github.io/posts/Promise A+规范.md">解析函数规范</a>
* 如果onFulfilled或者onRejected方法抛出一个异常e，promise2必须使用e作为原因拒绝掉（rejected）。
* 如果onFulfilled不是一个函数并且promise1到了fulfilled状态，那么promise2必须在与promise1的值相同的情况下转换到fulfilled状态。
* 如果onRejected不是一个函数并且promise1到了rejected状态，那么promise2必须在与promise1的原因相同的情况下转换到rejected状态。</p>
<div class="highlight"><pre style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#fff;font-weight:bold">Promise</span>.prototype.then = <span style="color:#fff;font-weight:bold">function</span>(onFullfilled, onRejected) {
    <span style="color:#fff;font-weight:bold">let</span> promise = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">Promise</span>(<span style="color:#fff;font-weight:bold">function</span>(resolve, reject){
        <span style="color:#fff;font-weight:bold">try</span>{
            <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">this</span>.status === RESOLVED){
                <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">typeof</span> onFullfilled === <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>){
                    <span style="color:#fff;font-weight:bold">let</span> x = onFullfilled(<span style="color:#fff;font-weight:bold">this</span>.value);  <span style="color:#007f7f">// fulfilled状态则立即执行onFullfilled函数
</span><span style="color:#007f7f"></span>                    <span style="color:#007f7f">// TODO 解析函数
</span><span style="color:#007f7f"></span>                }<span style="color:#fff;font-weight:bold">else</span>{
                    resolve(<span style="color:#fff;font-weight:bold">this</span>.value);
                }
            }
            <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">this</span>.status === REJECTED){
                <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">typeof</span> onRejected === <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>){
                    <span style="color:#fff;font-weight:bold">let</span> x = onRejected(<span style="color:#fff;font-weight:bold">this</span>.reason); 
                    <span style="color:#007f7f">// TODO 解析函数
</span><span style="color:#007f7f"></span>                }<span style="color:#fff;font-weight:bold">else</span>{
                    reject(<span style="color:#fff;font-weight:bold">this</span>.reason)
                }
            }
            <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">this</span>.status === PENDING){
                <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">typeof</span> onFullfilled === <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>){
                    <span style="color:#fff;font-weight:bold">this</span>.onFullfilledList.push(<span style="color:#fff;font-weight:bold">function</span>(){<span style="color:#007f7f">// 这里需要在onFullfilled函数之外包一层，在onFullfilled执行之后，获取结果并执行解析函数
</span><span style="color:#007f7f"></span>                        <span style="color:#fff;font-weight:bold">let</span> x = onFullfilled(<span style="color:#fff;font-weight:bold">this</span>.value);
                        <span style="color:#007f7f">// TODO 解析函数
</span><span style="color:#007f7f"></span>                    }); 
                }
                <span style="color:#fff;font-weight:bold">if</span>(<span style="color:#fff;font-weight:bold">typeof</span> onRejected === <span style="color:#0ff;font-weight:bold">&#34;function&#34;</span>){
                    <span style="color:#fff;font-weight:bold">this</span>.onRejectedList.push(<span style="color:#fff;font-weight:bold">function</span>(){
                        <span style="color:#fff;font-weight:bold">let</span> x = onRejected(<span style="color:#fff;font-weight:bold">this</span>.reason);  
                        <span style="color:#007f7f">// TODO 解析函数
</span><span style="color:#007f7f"></span>                    });
                }
            }
        }<span style="color:#fff;font-weight:bold">catch</span>(err){
            reject(err)
        }
    })
    <span style="color:#fff;font-weight:bold">return</span> promise
}
</code></pre></div>
<p>上面的实现，满足了除解析流程的其他规范，下面来详细实现解析函数;</p>

<h2 id="promise实现-part-3">promise实现&mdash;part 3</h2>

<p>在Promise/A+规范中，解析函数是这样规定的：
promise解析函数是一个输入一个promise或者一个值的抽象的操作，我们表示为<a href="promise, x">[Resolve]</a>。如果x是一个thenable对象，在假定x的行为至少有点像一个promise的情况下，它会尝试让promise转换到x的状态。否则，他会用x的值完成promise的状态。</p>

<p>运行<a href="promise, x">[Resolve]</a>,需要遵循以下步骤：
* 如果promise和x指向同一个对象，那么用TypeError作为原因拒绝promise。
* 如果x是一个promise，判断它的状态：
    1. 如果x是pending状态，promise保留pending状态直到x变成fulfilled状态或者rejected状态。
    2. 如果x是fulfilled状态，那么用同样的值将整个promise完成。
    3. 如果x是rejected状态，那么用同样的原因拒绝promise。
* 如果x是一个对象或者函数:
    1. 让then变成x.then。
    2. 如果在检测x.then这个属性的结果时抛出一个异常e，把e作为原因拒绝promise。
    3. 如果then是一个函数，那么用x作为this来调用它，第一个参数是resolvePromise，第二个参数是rejectPromise：
    4. 如果resolvePromise被值y调用，那么运行<a href="promise, y">[Resolve]</a>。
    5. 如果rejectPromise被原因r触发，那么用r来拒绝promise。
    6. 如果resolvePromise和rejectPromise都被调用，或者使用相同的参数多次调用，那么第一次调用生效，其他之后的任何调用都忽略掉。
    7. 如果在调用then方法时抛出了一个异常e,如果resolvePromise和rejectPromise已经被调用了那么就忽略掉它。否则，使用e作为原因拒绝promise。
    8. 如果then不是一个函数，那么用x完成promise。
* 如果x不是一个对象或者函数，那么用x完成promise。</p>

<p>看着有点晕，我试着理解一下：</p>

  </article>
</section>


      </div>

      <footer class="footer">
  <section class="container">
    
      <p>Enter a text here.</p>
    
     © 2019
    
       · 
      Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
    
       · 
      [<a href="https://github.com/luizdepra/hugo-coder/tree/"></a>]
    
  </section>
</footer>

    </main>

    

  </body>

</html>
